m[,3]                # 3eme colonne de m
m[2,3]               # element m(2,3)
class(m)             # different de mode(m)
is.matrix(m)
p = matrix(a,ncol=2)  # par defaut byrow = FALSE
q = matrix(a,nrow=2)
q %*% p               # produit de matrices
q %*% m               # pb dimensions
diag(m)               # diagonale, meme si pas carree
t(m)                  # transpose
apply(m,1,sum)        # operation (sum) par ligne (1)
##################################
# exercice Tuto R sur les matrices
a <- sample(0:9, size=50, rep=TRUE)
M <- matrix(a, nrow=10, ncol=5); M
apply(M,2,mean)
apply(M,1,sd)
plot(M[,1], type="b") # valeurs de la colonne vs index
par(mfrow=c(2,3))
apply(M, 2, plot, type="b")
# Usage des  ...
m <- matrix(rnorm(60), nrow=20)
apply(m, 2, median)
apply(m, 2, quantile)
apply(m, 2, quantile, probs=c(1/3, 2/3))
apply(M, 1, sd)
ls <- list(1:5, "toto", c(T,F), M) # sans nom
ln <- list(x=1:5,nom="toto",z=c(T,F), M=M) # named
summary(ln) # default method
ls[[1]]     # extraction element 1 de la liste
ln$x        # idem lorsque le nom est connu
ls[[1]][2:3]
ln$M[1:2,2:4]
names(ln)
################
## DATA FRAME ##
?data.frame
a=sample(1:10); b=rep(c(1,2),5)
c <- c(rep("M",6),rep("F",4)) # facteur qualitatif
c <- factor(c)
x <- data.frame(a,b,c) # creation de la structure
gc()
3+3
2+2 # calculette...
methods(summary)
?mean
example(mean)
?"+"
?citation
citation()
install.packages("ade4")
## Charger un package peut definir de nouvelles methods
methods(plot)
library(ade4)
methods(plot)
example(dudi.pca)
objects() # liste des objects crees (who de matlab)
ls() # equivalent
ls(pattern="a") # objets contenant "a"
rm(list=ls()) # efface tous les objets crees
a <- c(1,2,4,6,7)
length(a)
c <- c("hyfh","ksdfhgks") # "c" fuction and R object
a <- rep(1,10)
b <- rep(c(10,12), 5)
1:10
seq(1,10)
seq(1,10, length=20)
####################################
## MANIPULATIONS DE VECTEURS
x <- vector(mode = "integer", length = 5)
is.vector(x)
e <- seq(1,20,by=2)
is.vector(e)
e[3]
e[c(3,8,1)]
e[c(1,3,7,8)][c(1,3)]
a <- c(rep(T,4),rep(F,2))
e>5
e[e>5]
e[e != 11]
e[e == 11]
########## Graphiques qq exemples
z <- seq(-4,4,len=200)
plot(z, dnorm(z), type="l", lwd=3, col="steelblue")
abline(h=0, col=8)
abline(v=0)
lines(z, dnorm(z, mean=2), lty=2)
lines(z, dnorm(z, sd=0.5), lty=3, col=2, lwd=2)
lines(z, dnorm(z, sd=0.1), lty=3, col=3, lwd=3)
title("densites de la loi normale")
legend("topleft",
c("N(0,1)","N(2,1)","N(0,0.5)","N(0,0.1)"),
lty=c(1,2,3,3),
col=c("steelblue",1,2,3),
lwd=c(3,1,2,3))
###############################
## Manipulation de MATRICES
a=1:10               # on reprend
?matrix              # methode par defaut?
m <- matrix(a,nrow=4) # avec recycling (warning)
dim(m)
m[,3]                # 3eme colonne de m
m[2,3]               # element m(2,3)
class(m)             # different de mode(m)
########## Graphiques qq exemples
z <- seq(-4,4,len=200)
plot(z, dnorm(z), type="l", lwd=3, col="steelblue")
abline(h=0, col=8)
abline(v=0)
lines(z, dnorm(z, mean=2), lty=2)
lines(z, dnorm(z, sd=0.5), lty=3, col=2, lwd=2)
lines(z, dnorm(z, sd=0.1), lty=3, col=3, lwd=3)
title("densites de la loi normale")
legend("topleft",
c("N(0,1)","N(2,1)","N(0,0.5)","N(0,0.1)"),
lty=c(1,2,3,3),
col=c("steelblue",1,2,3),
lwd=c(3,1,2,3))
###############################
## Manipulation de MATRICES
a=1:10               # on reprend
?matrix              # methode par defaut?
m <- matrix(a,nrow=4) # avec recycling (warning)
dim(m)
m[,3]                # 3eme colonne de m
m[2,3]               # element m(2,3)
class(m)             # different de mode(m)
is.matrix(m)
p = matrix(a,ncol=2)  # par defaut byrow = FALSE
q = matrix(a,nrow=2)
q %*% p               # produit de matrices
q %*% m               # pb dimensions
diag(m)               # diagonale, meme si pas carree
t(m)                  # transpose
apply(m,1,sum)        # operation (sum) par ligne (1)
##################################
# exercice Tuto R sur les matrices
a <- sample(0:9, size=50, rep=TRUE)
M <- matrix(a, nrow=10, ncol=5); M
apply(M,2,mean)
apply(M,1,sd)
plot(M[,1], type="b") # valeurs de la colonne vs index
par(mfrow=c(2,3))
apply(M, 2, plot, type="b")
# Usage des  ...
m <- matrix(rnorm(60), nrow=20)
########## Graphiques qq exemples
z <- seq(-4,4,len=200)
plot(z, dnorm(z), type="l", lwd=3, col="steelblue")
abline(h=0, col=8)
abline(v=0)
########## Graphiques qq exemples
par(1,1)
z <- seq(-4,4,len=200)
########## Graphiques qq exemples
par(mfrom=(1,1)
########## Graphiques qq exemples
par(mfrom=(1,1))
########## Graphiques qq exemples
par(mfrom=c(1,1))
example(dudi.pca)
1:10
1:10:2
1:10:2
1:10
1:10:2
1:10
##################################
# exercice Tuto R sur les matrices
a <- sample(0:9, size=50, rep=TRUE)
M <- matrix(a, nrow=10, ncol=5); M
apply(M,2,mean)
apply(M,1,sd)
plot(M[,1], type="b") # valeurs de la colonne vs index
par(mfrow=c(2,3))
apply(M, 2, plot, type="b")
# Usage des  ...
m <- matrix(rnorm(60), nrow=20)
apply(m, 2, median)
apply(m, 2, quantile)
apply(m, 2, quantile, probs=c(1/3, 2/3))
##################################
# exercice Tuto R sur les matrices
a <- sample(0:9, size=50, rep=TRUE)
z <- seq(-4,4,len=200)
plot(z, dnorm(z), type="l", lwd=3, col="steelblue")
################
## DATA FRAME ##
?data.frame
a=sample(1:10); b=rep(c(1,2),5)
c <- c(rep("M",6),rep("F",4)) # facteur qualitatif
c <- factor(c)
x <- data.frame(a,b,c) # creation de la structure
# Usage des  fonctions dans apply
m <- matrix(rnorm(60), nrow=20)
apply(m, 2, median)
apply(m, 2, quantile)
apply(m, 2, quantile, probs=c(1/3, 2/3))
ls <- list(1:5, "toto", c(T,F), M) # sans nom
ln <- list(x=1:5,nom="toto",z=c(T,F), M=M) # named
summary(ln) # default method
ls[[1]]     # extraction element 1 de la liste
ln$x        # idem lorsque le nom est connu
stateFacts = read.table("C:\Users\Nicolas\OneDrive\Documents\Cours\S7\Data\tp1\StateFacts.txt")
stateFacts = read.table("C:/Users/Nicolas/OneDrive/Documents/Cours/S7/Data/tp1/StateFacts.txt")
stateFacts
summary(stateFacts)
mean(stateFacts)
var(stateFacts)
max(staetFacts)
max(statetFacts)
max(stateFacts)
summary(stateFacts[1,])
mean(stateFacts[1,])
mean(stateFacts[,1])
mean(stateFacts[1,1])
mean(stateFacts)
stateFacts[1,]
stateFacts[,1]
stateFacts[,2]
stateFacts[,3]
mean(stateFacts[,3])
table(stateFacts)
head(stateFacts)
stateFacts
row.names(stateFacts)
stateFacts$Region <- as.factor(state$Region)
stateFacts$Region <- as.factor(stateFacts$Region)
summary(stateFacts)
stateFacts$Region <- as.factor(stateFacts$Region)
states$Pop
stateFacts = read.table("C:/Users/Nicolas/OneDrive/Documents/Cours/S7/Data/tp1/StateFacts.txt", header=T, row.names = 1)
stateFacts
row.names(stateFacts)
stateFacts$Region <- as.factor(stateFacts$Region) # marche pas
states$Pop
stateFacts$Pop
attach(stateFacts$Pop)
summary(stateFacts)
mean(stateFacts)
var(stateFacts)
sd(staetFacts)
max(stateFacts)
max(stateFacts)
stateFacts$Region <- as.factor(stateFacts$Region)
quantile.default(stateFacts$Analphab)
sum(stateFacts$Revenu<5000)
sum(stateFacts$Pop^2)
tapply(stateFacts$Meurtre, stateFacts$Region, mean)
stateFacts[1:5, c(1,6,10)]
?cut
# fichier dans le working dir de RStudio
states = read.table("C:/Users/Nicolas/OneDrive/Documents/Cours/S7/Data/tp1/StateFacts.txt", header=T, row.names = 1)
head(states)
row.names(states)
colnames(states)
dim(states)
summary(states) # Region is char by default
states$Region <- as.factor(states$Region)
summary(states) # Region is now factor: ok
# selection d'objets (comme une liste)
states[[1]]    # = var de rang 1 (Pop)
states$Pop     # idem car named list
states[[1]][1] # car states[[1]] vector
states[2,3]    # car hérite aussi de la class "matrix"
## 2.5 - comprendre attach(), detach()
states$Pop
Pop
attach(states)   # rend visible les variables de states
Pop
detach(states)
Pop
# 2.6 sauvegarde au format interne R
save(states, file="States.Rdata")
summary(states$Region) # method summary.factor
summary(states$Apb)    # method summary.numeric
summary(states)        # summary.data.frame
summary(states$Etat)   # why??
## 3) sur stat élémentaires de states
attach(states)
mean(states$Revenu)
mean(Revenu)
sd(Meurtre)
sum(Revenu>5000) # nb d'états de revenu>5000
apply(states[,-c(1, 10)], 2, mean)
colnames(states)[4] <- "Apb"
sum(states$Pop^2)
summary(states) # vérif; method summary.data.frame
detach(states)
states$Region <- factor(states$Region)
# sauvegarde au format interne R (écrase la précédente)
save(states, file="States.Rdata")
### Utiliser en début de session (workspace vide)
load("States.Rdata")
attach(states)
# (2.8)
tapply(Meurtre, Region, mean)
## (6)
states[1:10,]
states[(nrow(states)-4):nrow(states),]
states[1:5, c(1, 6,10)]   # avec num col
states[1:5, c("Etat", "Meurtre", "Region")] # avec nom var
# d) selection d'obs et de var
states[Region == "South" & Revenu > 4500, c("Etat", "Pop")]
## (7) Création ou modification de variables
RevenuE <- Revenu * 1.1 # constante arbitraire ici
summary(RevenuE)
## copie de Region en labels conçis: R - like: pas de tests if... then
RG <- factor(Region,labels=c("NC","NE","S","W")) #
## vérification (table see later)
table(RG)
table(Region)
table(RG, Region) # table de contingence de 2 faceurs identiques
## (7 c) Facteur par recodage d'une var quantitative
?cut
cut(Diplome, breaks = 3) # auto
### DEBUT DE SEANCE: RELOAD
load("States.Rdata")
attach(states)
summary(states) # Etat doit etre char et Region "factor"
# recrée FD cf TP Feuille 1
FD <- cut(Diplome, breaks = c(min(Diplome),47,57, max(Diplome)),
labels = c("a","b","c"), include.lowest = TRUE)
table(FD)
## Analyses préliminaires
## (1) NA?
ind <- c(2:9) # indices des var quantitatives
summary(states[,ind]) ## min, max, NA's...
## ou direct
sum(is.na(states)) # global
apply(is.na(states), 2, sum) # NA par col
## (2) ajouter un NA et le retrouver
states[12,2] <- NA
summary(states[,ind]) ## => see NA's...
apply(is.na(states), 2, sum) # par col
which(is.na(states), arr.ind = TRUE) # which row ?
states[is.na(Pop),] # none?
detach(states)
attach(states)
states[is.na(Pop),] # effect of attach...
## RESTORE data.frame
detach(states)
load("States.Rdata")
attach(states)
# (3) Histogramme = loi empirique approche la densité
par(mfrow=c(1,2))
hist(Meurtre, col=8)
hist(Apb, col=8)
hist(Meurtre, col=8, freq=F) # normalisé sur la densité
hist(Meurtre, col=2, freq=F, # comparé avec autre algo
breaks="Scott")          # de calcul nb de classes
setwd("C:/Users/Nicolas/OneDrive/Documents/Cours/S7/Data/tp3")
jussac <- read.table("jussac.txt", header=TRUE, row.names = 1)
head(jussac)
jussac <- jussac[, -1]
as.factor(jussac[,7])
actifs <- jussac[jussac$Type != "J",]
indsuc <- jussac[jussac$Type == "J",]
summary(actifs)
## (1) import in 2 formats
dfYC <- read.table("couleursYeuxCheveux.txt")
# Chargement du fichier (présent dans le répertoire de travail)
setwd("C:\Users\Nicolas\OneDrive\Documents\Cours\S7\Data")
# Chargement du fichier (présent dans le répertoire de travail)
setwd("C:\\Users\\Nicolas\\OneDrive\\Documents\\Cours\\S7\\Data")
dfYC <- read.table("couleursYeuxCheveux.txt", header = TRUE, row.names = 1)
class(dfYC)  # data.frame
dfYC
# Conversion en objet de classe table
tYC <- as.table(as.matrix(dfYC))
class(tYC)
tYC
# Profils ligne : distribution des cheveux pour chaque couleur d’yeux
profLigne <- prop.table(tYC, margin = 1)
round(profLigne, 3)
# Profils colonne : distribution des yeux pour chaque couleur de cheveux
profCol <- prop.table(tYC, margin = 2)
round(profCol, 3)
# Histogramme des profils lignes
barplot(t(profLigne), beside = TRUE, legend = TRUE,
col = rainbow(ncol(tYC)),
main = "Profils ligne : répartition des cheveux selon la couleur des yeux")
# Histogramme des profils colonnes
barplot(profCol, beside = TRUE, legend = TRUE,
col = rainbow(nrow(tYC)),
main = "Profils colonne : répartition des yeux selon la couleur des cheveux")
# Test du chi² d'indépendance
testChi2 <- chisq.test(tYC)
testChi2
library(ade4)
help(dudi.coa)
coaYC <- dudi.coa(tYC, scannf = FALSE, nf = 3)
tYC <- as.table(as.matrix(dfYC))
coaYC <- dudi.coa(tYC, scannf = FALSE, nf = 3)
# Conversion en numérique (si nécessaire)
dfYC[] <- lapply(dfYC, as.numeric)
# Conversion en table
tYC <- as.table(as.matrix(dfYC))
coaYC <- dudi.coa(tYC, scannf = FALSE, nf = 3)
## On lit la table de contingence :
## - header = TRUE : première ligne = noms de colonnes (couleur des cheveux)
## - row.names = 1 : première colonne = noms des lignes (couleur des yeux)
setwd("C:\\Users\\Nicolas\\OneDrive\\Documents\\Cours\\S7\\Data")
dfYC <- read.table("couleursYeuxCheveux.txt",
header = TRUE,
row.names = 1)
class(dfYC)   # data.frame
dfYC
str(dfYC)     # colonnes doivent être "numeric"
## Conversion en objet "table" (2 facteurs croisés)
tYC <- as.table(as.matrix(dfYC))
class(tYC)    # "table"
tYC
# Nombre total d'individus
n <- sum(tYC)
# Profils ligne : P(Cheveux | Yeux) (proportions conditionnelles par ligne)
profL <- prop.table(tYC, 1)  # margin = 1 -> lignes
profL
# Profils colonne : P(Yeux | Cheveux) (proportions conditionnelles par colonne)
profC <- prop.table(tYC, 2)  # margin = 2 -> colonnes
profC
# Marges (distributions simples)
margeYeux    <- margin.table(tYC, 1) / n
margeCheveux <- margin.table(tYC, 2) / n
margeYeux
margeCheveux
# Histogrammes (barplots) des distributions marginales
par(mfrow = c(1, 2))
barplot(margeYeux,
main = "Distribution des couleurs d'yeux",
ylab = "Proportion", xlab = "Yeux")
barplot(margeCheveux,
main = "Distribution des couleurs de cheveux",
ylab = "Proportion", xlab = "Cheveux")
par(mfrow = c(1, 1))
# Test du χ² d'indépendance
test.chi <- chisq.test(tYC)
test.chi
test.chi$statistic  # valeur de la statistique χ²
test.chi$p.value    # p-valeur
library(ade4)
?dudi.coa
## On peut passer directement la table de contingence sous forme data.frame
coaYC <- dudi.coa(dfYC, scannf = FALSE, nf = 4)  # nf = nb d’axes conservés
coaYC
summary(coaYC)   # contient déjà la décomposition de l'inertie
## Décomposition détaillée de l’inertie
inertYC <- inertia.dudi(coaYC)
inertYC
# 1) Statistique χ² du test d’indépendance
chi2 <- as.numeric(test.chi$statistic)
# 2) Inertie totale du nuage en AFC = somme des valeurs propres
Itot <- sum(coaYC$eig)
# 3) Comparaison avec χ² / n
chi2_over_n <- chi2 / n
chi2
Itot
chi2_over_n
all.equal(Itot, chi2_over_n)  # doit renvoyer TRUE (ou quasi)
plot_afc_cos2 <- function(coa.obj, axes = c(1, 2)) {
ax1 <- axes[1]
ax2 <- axes[2]
## Coordonnées factorielles
li <- coa.obj$li[, c(ax1, ax2), drop = FALSE]  # lignes (yeux)
co <- coa.obj$co[, c(ax1, ax2), drop = FALSE]  # colonnes (cheveux)
## Inerties + cos² (qualité de représentation sur chaque axe)
inert <- inertia.dudi(coa.obj,
row.inertia = TRUE,
col.inertia = TRUE)
## row.rel / col.rel : cos² par axe (rel. contributions)
row_cos2_axes <- inert$row.rel[, c(ax1, ax2), drop = FALSE]
col_cos2_axes <- inert$col.rel[, c(ax1, ax2), drop = FALSE]
## cos² sur le plan (somme des cos² sur les 2 axes)
row_cos2_plane <- rowSums(row_cos2_axes)
col_cos2_plane <- colSums(col_cos2_axes)
## Échelles du graphique
xrange <- range(li[, 1], co[, 1])
yrange <- range(li[, 2], co[, 2])
## Taille des points proportionnelle au cos² (normalisée)
cex_row <- 0.8 + 3 * row_cos2_plane / max(row_cos2_plane)
cex_col <- 0.8 + 3 * col_cos2_plane / max(col_cos2_plane)
## Pourcentage d'inertie expliqué par chaque axe
perc1 <- round(100 * coa.obj$eig[ax1] / sum(coa.obj$eig), 1)
perc2 <- round(100 * coa.obj$eig[ax2] / sum(coa.obj$eig), 1)
## Plot vide
plot(xrange, yrange, type = "n",
xlab = paste0("Axe ", ax1, " (", perc1, " % d'inertie)"),
ylab = paste0("Axe ", ax2, " (", perc2, " % d'inertie)"),
main = "AFC Yeux/Cheveux – points ∝ cos²")
abline(h = 0, v = 0, lty = 3)
## Lignes (yeux) en bleu
points(li[, 1], li[, 2],
pch = 19, col = "steelblue", cex = cex_row)
text(li[, 1], li[, 2],
labels = rownames(li),
pos = 3, col = "steelblue4")
## Colonnes (cheveux) en rouge
points(co[, 1], co[, 2],
pch = 17, col = "tomato", cex = cex_col)
text(co[, 1], co[, 2],
labels = rownames(co),
pos = 3, col = "tomato4")
legend("topright",
legend = c("Yeux (lignes)", "Cheveux (colonnes)"),
pch = c(19, 17),
col  = c("steelblue", "tomato"),
bty  = "n")
}
## Appel de la fonction pour tracer la représentation simultanée
plot_afc_cos2(coaYC, axes = c(1, 2))
#################################################
